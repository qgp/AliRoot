#!/bin/sh

# $Id$

#############################################################################
# alibtool - a shell script to help makeing modules for AliRoot Makefile
#############################################################################
#
#
# SYNOPSIS
# alirun <command> <commandparameters>
#
# command must be one of the following:
#
#         mkmodule
#         depend
#         dependF
#
#
# DESCRIPTION
#
# This scipts is called with a primary command and a commandparameter. It generates output on stdout, so normally it is called with a redirection like
#
#   alibtool mkmoudle STEER > STEER/module.mk
#
# The command is one of the following
#
# depend
#        Makes the dependencies for the file specified as second argument (c and cxx files)
#
# dependF
#        Makes the dependencies for the file specified as second argument (fortran files)
#
# mkmoudle
#        Creates the module.mk for the the given directory specified as the second argument.
#
# MKMOUDLE
#
# When alibtool is called with the mkmodule command it searches the directory given as the second argument for files called *.pkg. If a file (possibly several) is found, it will create a file called module.mk based on these files. For example if running alibtool mkmodule STEER, it will search the STEER directory and create STEER/module.mk based on all .pkg files is STEER directory. If a file called libSTEER.pkg is found, then module.mk will have a section devoted to makeing library libSTEER.so with alle the sourcefiles specified in libSTEER.pkg. If a file called binSTEER.pkg is found the module.mk file will create an executable called STEER. Several *.pkg files can be placed in the same directory. The module.mk files is created on background of build/header.tpl and build/module.mk by variable substituion of variables @MODULE@ @PACKAGE@ and @TYPE@.
#
# PKG FILES
#
#
# The syntax for the pkg file is very simple. You specify the sources, headers and possibly extra include or link options. The *.pkg files is just inserted "as is" in the module.mk file, so normal Makefile syntax can be used. These variables can be specified: SRCS, FSRCS, CSRCS, HDRS, CHDRS, DHDR, EINCLUDE, ELIBS, ELIBSDIR, PACKFFLAGS, PACKCFLAGS, PACKCXXFLAGS. The first five is just the c++ sources, fortran sources, c sources, c++ headers and c headers. DHDR is the dictionary header and is the LinkDef file. EINCLUDE, ELIBS and ELIBSDIR is extra includedirs, libraries and library search paths. If for example a binary is to be linked against the variable ELIBSDIR would be set to lib/tgt_$ALICE_TARGET. Notice that -L and -l is not needed. If the PACKFFLAGS, PACKCFLAGS or PACKCXXFLAGS is not set it will be set to the default options (Set in config/Makefile.$ALICE_TARGET. For example on Linux GEANT321 has to be compiled without -O options, so a line like PACKFFLAGS := $(filter-out -O%,$(FFLAGS)) is needed.
#
#
# DEPEND
# 
# If alibtool is called with the depend command it will generate a dependecy file for the sourcefile given as second argument. This only goes for c++ and c files. If dependencies for fortran-fiels is needed, call alibtool with command dependF. The dependencies is made with rmkdepend.
#
#
# DEPENDF
#
# The same as depend, but for fortran files.
#
#C<
###########################################################################
 

MkDepend()
{
IPATH="-I$ROOTSYS/cint/include"
IPATH=$IPATH" -I/usr/include/g++-2"                   #Linux gcc 2.x
IPATH=$IPATH" -I/opt/SUNWspro/WS6U1/include/CC/Cstd"  #Sun CC5
IPATH=$IPATH" -I/usr/include/cxx"                     #DEC cxx
IPATH=$IPATH" -I/opt/aCC/include"                     #HP-UX aCC
rmkdepend -f- -w 3000 -- $IPATH $* | sed -e "s@^\(.*\)\/\(.*\)\.o:@\1\/tgt_${ALICE_TARGET}\/\2.d \1\/tgt_${ALICE_TARGET}/\\2.o:@" -e 's@^#.*$@@' -e '/^$/d'
}
MkDependF()
{
rmkdepend -f- -Y -w 3000 -- $* | sed -e "s@^\(.*\)\/\(.*\)\.o:@\1\/tgt_${ALICE_TARGET}\/\2.d \1\/tgt_${ALICE_TARGET}/\\2.o:@" -e 's@^#.*$@@' -e '/^$/d'
}

MkModule()
{
module=$1
#This one gets all the library pkg files
tempo=`find ${module} -name "lib*.pkg"  | sed -e "sQ${module}/libQQ" -e "sQ\.pkgQQ"`

echo "#**************************************************************************";
echo "#**** This file is automatically generated from the mkmodules script  *****";
echo "#****          DO NOT EDIT!!                                          *****";
echo "#**************************************************************************";

for i in $tempo; do
    package=$i;
    type=lib;
    MkModuleLib $package
done;

#This one gets all the binary(executable) pkg files
tempo=`find ${module} -name "bin*.pkg"  | sed -e "sQ${module}/binQQ" -e "sQ\.pkgQQ"`

for i in $tempo; do
    package=$i;
    type=bin;
    MkModuleLib $package 
done;

#Now make general bottom for every module (Clean and so on)
    cat build/clean.tpl | sed -e "sQ\@MODULE@Q${module}Qg"
}

MkModuleLib()
{
    file=$module/$type$i.pkg
    cat build/header.tpl | sed -e "sQ\@MODULE@Q${module}Qg"  -e "sQ@PACKAGE@Q${package}Qg" -e "sQ\@TYPE@Q${type}Qg"
    echo;
    cat $file;
    echo;
    cat build/module.tpl | sed -e "sQ\@MODULE@Q${module}Qg"  -e "sQ@PACKAGE@Q${package}Qg" -e "sQ\@TYPE@Q${type}Qg"

}

case $1 in
depend)
    MkDepend $2
    ;;
dependF)
    MkDependF $2
    ;;
mkmodule)
    MkModule $2
    ;;
esac;


















