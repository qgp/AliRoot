//  **************************************************************************
//  * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
//  *                                                                        *
//  * Author: The ALICE Off-line Project.                                    *
//  * Contributors are mentioned in the code where appropriate.              *
//  *                                                                        *
//  * Permission to use, copy, modify and distribute this software and its   *
//  * documentation strictly for non-commercial purposes is hereby granted   *
//  * without fee, provided that the above copyright notice appears in all   *
//  * copies and that both the copyright notice and this permission notice   *
//  * appear in the supporting documentation. The authors make no claims     *
//  * about the suitability of this software for any purpose. It is          *
//  * provided "as is" without express or implied warranty.                  *
//  **************************************************************************

#include "AliHMPIDDigitN.h"//class header
#include <TCanvas.h>     //TestSeg()
#include <TLine.h>       //TestSeg()
#include <TLatex.h>      //TestSeg()
#include <TPolyLine.h>   //DrawPc() 
#include <TGStatusBar.h> //Zoom()
#include <TRootCanvas.h> //Zoom() 
ClassImp(AliHMPIDDigitN)

/*
Any given LDC collects data from a number of D-RORC cards connected to this same LDC by separate DDLs. This data is stored in corresponding number
of DDL buffers.

Each DDL buffer corresponds to a single D-RORC. The data this buffer contains are hardware generated by D-RORC. The buffer starts with common header 
which size and structure is standartized and mandatory for all detectors.
The header contains among other words, so called Equipment ID word. This unique value for each D-RORC is calculated as detector ID << 8 + DDL index. 
For HMPID the detector ID is 6 (reffered in the code as kRichRawId) while DDL indexes are from 0 to 13.

Common header might be followed by the private one although  HMPID has no any private header, just uses the common one.

Single HMPID D-RORC serves one half of a chamber i.e. 3 photocathodes even LDC for left part( PCs 0-2-4) and odd LDC for right part(1-3-5) 
as it's seen from electronics side.

So the LDC -chamber-ddl map is:
DDL index  0 -> ch 1 left -> DDL ID 0x600          DDL index  1 -> ch 1 right -> DDL ID 0x601 
DDL index  2 -> ch 2 left -> DDL ID 0x602          DDL index  3 -> ch 2 right -> DDL ID 0x603 
DDL index  4 -> ch 3 left -> DDL ID 0x604          DDL index  5 -> ch 3 right -> DDL ID 0x605 
DDL index  6 -> ch 4 left -> DDL ID 0x606          DDL index  7 -> ch 4 right -> DDL ID 0x607 
DDL index  8 -> ch 5 left -> DDL ID 0x608          DDL index  9 -> ch 5 right -> DDL ID 0x609 
DDL index 10 -> ch 6 left -> DDL ID 0x60a          DDL index 11 -> ch 6 right -> DDL ID 0x60b 
DDL index 12 -> ch 7 left -> DDL ID 0x60c          DDL index 13 -> ch 7 right -> DDL ID 0x60d 

HMPID FEE as seen by single D-RORC is composed from a number of DILOGIC chips organized in vertical stack of rows. 
Each DILOGIC chip serves 48 channels for the 8x6 pads (reffered in the code as kDilX,kDilY). Channels counted from 0 to 47.

The mapping inside DILOGIC chip has the following structure (see from electronics side):

5  04 10 16 22 28 34 40 46
4  02 08 14 20 26 32 38 44
3  00 06 12 18 24 30 36 42
2  01 07 13 19 25 31 37 43
1  03 09 15 21 27 33 39 45
0  05 11 17 23 29 35 41 47
    
    0  1  2  3  4  5  6  7  padx

10 DILOGIC chips composes so called "row" in horizontal direction (reffered in the code as kNdil), so the row is 80x6 pads structure. 
DILOGIC chips in the row are counted from right to left as seen from electronics side, from 1 to 10.
24 rows are piled up forming the whole FEE served by single D-RORC, so one DDL sees 80x144 pads separated in 3 photocathodes.
Rows are counted from 1 to 24 from top    to bottom for right  half of the chamber (PCs 1-3-5) as seen from electronics side, meaning even LDC number
                          and from bottom to top    for left   half of the chamber (PCs 0-2-4) as seen from electronics side, meaning odd LDC number.

HMPID raw word is 32 bits with the structure:   
   00000             rrrrr                      dddd                               aaaaaa                          qqqqqqqqqqqq 
 5 bits zero  5 bits row number (1..24)  4 bits DILOGIC chip number (1..10) 6 bits DILOGIC address (0..47)  12 bits QDC value (0..4095)
*/
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void AliHMPIDDigitN::Print(Option_t*)const
{
// Print current digit  
// Arguments: option string not used
//   Returns: none    
  Printf("pad=(%2i,%2i,%3i,%3i),pos=(%.2f,%.2f) QDC=%8.3f, TID=(%5i,%5i,%5i) raw r=%2i d=%2i a=%2i",
               Ch(),Pc(),PadX(),PadY(),LorsX(),LorsY(), Qdc(),  fTracks[0],fTracks[1],fTracks[2], Row(), Dilogic(), Addr());
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void AliHMPIDDigitN::PrintSize()
{
// Print all segmentaion related sizes
// Arguments: none
//   Returns: none    
  Printf("-->pad    =(%6.2f,%6.2f) cm dead zone %.2f cm\n"
         "-->PC     =(%6.2f,%6.2f) cm\n"
         "-->all PCs=(%6.2f,%6.2f) cm",
               SizePadX(),SizePadY(),SizeDead(),SizePcX(),SizePcY(),SizeAllX(),SizeAllY());
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void AliHMPIDDigitN::TestSeg()
{
// Draws the picture of segmentation   
// Arguments: none
//   Returns: none     
  TCanvas *pC=new TCanvas("pads","View from electronics side, IP is behind the picture.");pC->ToggleEventStatus();
  gPad->AddExec("test","AliHMPIDDigitN::Zoom()");
  DrawPc();  
}//TestSeg()
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void AliHMPIDDigitN::Zoom()
{
// Show info about current cursur position in status bar of the canvas
// Arguments: none
//   Returns: none     
  TCanvas *pC=(TCanvas*)gPad; 
  TRootCanvas *pRC= (TRootCanvas*)pC->GetCanvasImp();
  TGStatusBar *pBar=pRC->GetStatusBar();
  pBar->SetParts(5);
  Float_t x=gPad->AbsPixeltoX(gPad->GetEventX());
  Float_t y=gPad->AbsPixeltoY(gPad->GetEventY());
  AliHMPIDDigitN dig(1,x,y,100);
  pBar->SetText(Form("(p=%i,x=%i,y=%i)  (r%i d%i a%i)",dig.Pc(),dig.PadX(),dig.PadY(),dig.Row(),dig.Dilogic(),dig.Addr()),4);
  if(gPad->GetEvent()==1){
    new TCanvas("zoom",Form("Row %i DILOGIC %i",dig.Row(),dig.Dilogic()));  
  }
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
void AliHMPIDDigitN::DrawPc() 
{ 
// Utility methode draws HMPID chamber PCs on event display.
// Arguments: none
//   Returns: none      
//  y6  ----------  ----------
//      |        |  |        |
//      |    4   |  |    5   |
//  y5  ----------  ----------
//
//  y4  ----------  ----------
//      |        |  |        |
//      |    2   |  |    3   |   view from electronic side
//  y3  ----------  ----------
//          
//  y2  ----------  ----------
//      |        |  |        |
//      |    0   |  |    1   |
//  y1  ----------  ----------
//      x1      x2  x3       x4
  gPad->Range(-5,-5,SizeAllX()+5,SizeAllY()+5); 
  Float_t x1=0,x2=SizePcX(),x3=SizePcX()+SizeDead(),                                                  x4=SizeAllX();
  Float_t y1=0,y2=SizePcY(),y3=SizePcY()+SizeDead(),y4=2*SizePcY()+SizeDead(),y5=SizeAllY()-SizePcY(),y6=SizeAllY();

  Float_t xL[5]={x1,x1,x2,x2,x1}; //clockwise
  Float_t xR[5]={x3,x3,x4,x4,x3};  
  Float_t yD[5]={y1,y2,y2,y1,y1};
  Float_t yC[5]={y3,y4,y4,y3,y3};  
  Float_t yU[5]={y5,y6,y6,y5,y5};
    
  TLatex t; t.SetTextSize(0.01); t.SetTextAlign(22);
  Int_t iColLeft=29,iColRight=41;
  TPolyLine *pc=0;  TLine *pL; Float_t x0=0,y0=0,wRow=kDilY*SizePadY(),wDil=kDilX*SizePadX();
  for(Int_t iPc=0;iPc<kNpc;iPc++){
    if(iPc==4) {pc=new TPolyLine(5,xL,yU);t.DrawText(x1-3.5,y6-20,"PC4");x0=x1;y0=y5;} if(iPc==5) {pc=new TPolyLine(5,xR,yU);t.DrawText(x4+3.5,y6-20,"PC5");x0=x3;y0=y5;}
    if(iPc==2) {pc=new TPolyLine(5,xL,yC);t.DrawText(x1-3.5,y4-20,"PC2");x0=x1;y0=y3;} if(iPc==3) {pc=new TPolyLine(5,xR,yC);t.DrawText(x4+3.5,y4-20,"PC3");x0=x3;y0=y3;}
    if(iPc==0) {pc=new TPolyLine(5,xL,yD);t.DrawText(x1-3.5,y2-20,"PC0");x0=x1;y0=y1;} if(iPc==1) {pc=new TPolyLine(5,xR,yD);t.DrawText(x4+3.5,y2-20,"PC1");x0=x3;y0=y1;}    
    (iPc%2)? pc->SetFillColor(iColLeft): pc->SetFillColor(iColRight);
    pc->Draw("f");
    for(Int_t i=1;i<=8 ;i++){//draw row lines (horizontal)
      Float_t y=y0+i*wRow;
      Int_t row=i+iPc/2*8; if(iPc%2!=0) row=25-row; t.DrawText(x0-1,y -3,Form("r%i",row)); 
      if(i==8) break;                                      //do not draw the last line of PC
      pL=new TLine(x0,y,x0+SizePcX(),y);   pL->Draw(); 
    }    
    for(Int_t iDil=1;iDil<=10;iDil++){Float_t x=x0+iDil*wDil;t.DrawText(x -3,y0-1,Form("d%i",11-iDil));   if(iDil==10) break;    pL=new TLine(x,y0,x,y0+SizePcY());  pL->Draw();}  
  }      
}//DrawPc()
