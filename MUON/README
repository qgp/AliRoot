/**************************************************************************
 * Copyright(c) 1998-1999, ALICE Experiment at CERN, All rights reserved. *
 *                                                                        *
 * Author: The ALICE Off-line Project.                                    *
 * Contributors are mentioned in the code where appropriate.              *
 *                                                                        *
 * Permission to use, copy, modify and distribute this software and its   *
 * documentation strictly for non-commercial purposes is hereby granted   *
 * without fee, provided that the above copyright notice appears in all   *
 * copies and that both the copyright notice and this permission notice   *
 * appear in the supporting documentation. The authors make no claims     *
 * about the suitability of this software for any purpose. It is          *
 * provided "as is" without express or implied warranty.                  *
 **************************************************************************/

/* $Id$ */

==========================================================
Please add  to this README file all information concerning 
config files, simulation, digitalization, clusterization, 
reconstruction and macro analysis

==========================================================
 How to check that your aliroot is working well
==========================================================
There is a script file AlirootRun_MUONtest.sh which 
allows for simulating, reconstructing and making the
invariant analysis of the generated Upsilon (1S).
The used configuration file is Config.C in MUON 
directory.
You have to type :
source $ALICE_ROOT/MUON/AlirootRun_MUONtest.sh 
The results of this test are saved in test_out/ directory.
Please note that the CDB (Condition DataBase) is now always *required* 
to perform either simulation or reconstruction. For the moment, a version
 of that CDB is stored in CVS, so you should have one already in MUON/Calib
subdirectories.

==========================================================
 How to check that your aliroot is working VERY well
==========================================================
There is a script file AlirootRun_MUONlongtest.sh which
allows for simulating, reconstructing and making the
-+invariant analysis of the generated Upsilon (1S).
This script generates a large number of Upsilon (20k) 
in order to access differential quantities. 
The used configuration file is Config.C in MUON
directory.
One should really run this script to check if the MUON 
code can process a large number of events WITHOUT errors,
in particular before making important commits !!

You have to type :
$ALICE_ROOT/MUON/AlirootRun_MUONtestlong.sh
The results of this test are saved in testlong_out/ directory
and will be kept in CVS

(NOTE: the macros performing the calculations/plots MUONefficiency.C 
and MUONplotEfficiency.C are also able to handle J/Psi if 
Config.C is modified accordingly )

==========================================================
 How to run a MUON generation
==========================================================
aliroot
root [0] gAlice->Run(10,"$ALICE_ROOT/MUON/Config.C");

1 single muon of 7 GeV/c in the MUON spectrometer 
acceptance will be simulated using geant3. 
Hit information will be store in the root file in the
execution directory.
If you want to change the option or to define a new directory
for hits, you have to do the following before:
root [0] gAlice->SetConfigFunction("Config( \"/home/martinez/aliroot/work_NewIO/test/\" , \"box\" );"); 

============================================================
 How to run MUONCheck macro
============================================================
To check the content of a root data file, the MUONCheck
provides a ascii output on screen.

To compile MUONCheck.C
.includepath $ALICE_ROOT/STEER
.includepath $ALICE_ROOT/MUON
.includepath $ALICE_ROOT/MUON/mapping
.L $ALICE_ROOT/MUON/MUONCheck.C++
To Load
gSystem->Load("$ALICE_ROOT/MUON/MUONCheck_C.so")

To print Kine : (default file is galice.root )
MUONkine() or MUONkine(##,"galice.root") for the event number ##

To print hits : (default file is galice.root if not MUONhits("toto.root""); )
MUONhits()  or MUONhits(##,"galice.root") for the event number ##

To print digits : (default file is galice.root)
MUONdigits()  or MUONdigits(##,"galice.root") for the event number ##

To print sdigits : (default file is galice.root)
MUONsdigits()  or MUONsdigits(##,"galice.root") for the event number ##

To print rawcluster : (default file is galice.root)
MUONrecpoints() or MUONrecpoints(##,"galice.root") for the event number ##

To print trigger : (default file is galice.root)
MUONrectrigger() or MUONrectrigger(##,"galice.root") for the event number ##

....

============================================================
 How to check the Geometry with the new Geometrical modeler
 ftp://root.cern.ch/root/doc/chapter16.pdf
 http://agenda.cern.ch/fullAgenda.php?ida=a05212
============================================================
gAlice->Init("$ALICE_ROOT/MUON/Config.C");
gGeoManager->GetMasterVolume()->Draw();


============================================================
 How to check the overlap with the new Geometrical modeler
 ftp://root.cern.ch/root/doc/chapter16.pdf
 http://agenda.cern.ch/fullAgenda.php?ida=a05212
============================================================
gAlice->Init("$ALICE_ROOT/MUON/Config.C");
gGeoManager->CheckOverlaps();
gGeoManager->PrintOverlaps();

============================================================
 How to run MUONdisplay
============================================================
First you need to perform a full simulation: 
generation, digitalisation and clusterisation
To run MUONdisplay with Root 5.04/00 you need to get a fix in
the gpad/src/TPad.cxx from Root CVS:
 cvs update -r 1.200 gpad/src/TPad.cxx
and recompile root. 

.L $ALICE_ROOT/MUON/MUONdisplay.C
MUONdisplay(0,"galice.root")

============================================================
 Tracking parameters, cuts, energy loss and physics processes
============================================================
Tracking parameters in MUON are automatically defined by GEANT
MUON takes the default values of CUTs  and physics processes
defined by the Config files, except for the gas mixture medium 
of the tracking chambers. The CUT's and physics processes of
the gas mixture medium  is then defined in the galice.cuts file
in the data directory. In particular ILOSS parameter MUST be
equal unity (1) in order simulate a realistic energy loss
distribution (mean value and fluctuations) in the active gas.

============================================================
 Tracking of particle in the magnetic field
============================================================
GEANT has two ways for tracking charged particles in the 
magnetic field: HELIX et RKUTA.
HELIX is faster and works well if the gradient of magnetic 
field is small. 
For MUON, HELIX is a not a good approximation and we must 
use RKUTA to get the optimal mass resolution of the 
spectrometer. The choice of HELIX or RKUTA is done in the
config file when the magnetic field is defined:
  AliMagFMaps* field = new AliMagFMaps("Maps","Maps", TRACKING, FACTOR, MAXB, AliMagFMaps::k4kG);
  gAlice->SetField(field);
TRACKING must be 1 for RKUTA and 2 for HELIX (the default value for aliroot is 2 (HELIX))
FACTOR allows you to set the magnetic field to 0, just putting FACTOR=0. Default value is 1.
MAXB is the maximum magnetic field which is 10.T

===========================================================
 MUON cocktail for physics ..............
===========================================================
There is a MUON cocktail generator of the muon sources in the
EVGEN directory. This class derives from AliGenCocktail.
In the init of this class I have filled the cocktail with 
the muon sources: J/Psi, Upsilon, Open Charm, Open Beauty, 
Pion, Kaons. The code needs only the production cross section 
at 4pi (for the moment this values are in the code since I 
prefere them do not be modified), and the code calculates the  
rate of particles in the acceptance, making the scaling based 
on the number of collisions for the hard probes and on the  
number of participants for soft sources: Pions and Kaons.

In the Genereate of this class all entries in the cocktail 
are called and we define a "primordial trigger" with requires 
a minimum number of muons above a Pt cut in the required acceptance.
In order to normalized to the real number of simulated events, 
there are 2 data members in the class fNsuceeded adn fNGenerate 
which tell us what is the biais source.

Enclose an example to use this generator:   
AliGenMUONCocktail * gener = new AliGenMUONCocktail();
gener->SetPtRange(1.,100.);       // Transverse momentum range  
gener->SetPhiRange(0.,360.);    // Azimuthal angle range 
gener->SetYRange(-4.0,-2.4);
gener->SetMuonPtCut(1.);
gener->SetMuonThetaCut(171.,178.);
gener->SetMuonMultiplicity(2);
gener->SetImpactParameterRange(0.,5.); // 10% most centra PbPb collisions
gener->SetVertexSmear(kPerTrack);  
gener->SetOrigin(0,0,0);        // Vertex position
gener->SetSigma(0,0,0.0);       // Sigma in (X,Y,Z) (cm) on IP position
gener->Init();
 
================================================================
 csh Script for the full reconstruction with raw data generator
================================================================
The rawdata generation and analysis is working with the new segmentation.
So the config file must use the version "AliMUONFactoryV3"

Generation
The method AliSimulation::SetWriteRawData("MUON") enables on 
the muon rawdata generation
aliroot -b << EOF  
AliSimulation MuonSim("$ALICE_ROOT/MUON/Config.C")
MuonSim.SetWriteRawData("MUON")
MuonSim.Run(10)
.q
EOF

Reconstruction
aliroot -b << EOF 
AliReconstruction MuonRec("galice.root");
MuonRec.SetInput("$YOUR_WORKING_DIRECTORY/");  Do not forget the slash at the end!
MuonRec.SetRunVertexFinder(kFALSE);
MuonRec.SetRunLocalReconstruction("MUON");
MuonRec.SetRunTracking("");
MuonRec.SetFillESD("MUON");
MuonRec.SetOption("MUON", "VS"); // to use VS cluster finder
// MuonRec.SetOption("MUON", "VS Original"); // to run VS and original track finder
// MuonRec.SetOption("MUON", "Combi"); // to run combined cluster / track finder
MMuonRec.Run();
.q
EOF



============================================================
 How to run MUONRecoCheck macro
============================================================
To check the muon reconstruction by comparing the reconstructed tracks
with the reference tracks made of "AliTrackReference" for the hits and
kinematic informations (TParticle) for the vertex.
This macro can be used to check the track reconstruction e.g. efficiency,
momentum resolution ... but also to make physics analysis whenever
track identification is needed.   

To compile MUONRecoCheck.C
.includepath $ALICE_ROOT/STEER
.includepath $ALICE_ROOT/MUON
.L $ALICE_ROOT/MUON/MUONRecoCheck.C+

// To run MUONRecoCheck
MUONRecoCheck(nEvent,"galice.root"); // nEvent = nb of events


============================================================
 How to run MUONTracker macro
============================================================
To make the track reconstruction directly from AliTrackReference hits 
which are recorded in TrackRefs.root during the simulation.
It can be used to check the reconstruction without clusterization.	

To compile MUONTracker.C
.includepath $ALICE_ROOT/STEER
.includepath $ALICE_ROOT/MUON
.L $ALICE_ROOT/MUON/MUONTracker.C+

// To run MUONTracker
MUONTracker(iEventMin,iEventMax,"galice.root"); // iEventMin: first event

===========================================================
 Macro  MUONGenerateGeometryData.C
===========================================================
						
Macro for generating the geometry data files
and mis-alignment data.

Geometry data files:
- MUON/data/volpath.dat file contains the volume paths 
for all alignable objects (modules & detection 
elements).
- MUON/data/transform.dat file contains the transformations
data (translation and rotation) for all alignable objects
(modules & detection elements)
- MUON/data/svmap.dat file contains all the information to link 
each geant volume (it can be extended to other virtual MC) with
a detection element. The point here is that a given detection
element, i.e. a slat chamber can consist of more geant volumes.
the correspondence is then defined in an input file.
Each time there is a change in the definition of MC geometry, these
input files must be re-generated via the macro  
MUONGenerateGeometryData.C

To be run from aliroot:
.x MUONGenerateGeometryData.C

The generated files do not replace the existing ones
but have different names (with extension ".out").
Replacement with new files has to be done manually.

If the appropiate flags are set (zeroAlign, resMisAlign and/or fullMisAlign)
zero, residual and/or full misalignment data are generated in a
local CDB folder (defaults are ResMisAlignCDB and FullMisAlignCDB
in the working directory). Inside the local CDB the path for the
alignment data is (and must be) "MUON/Align/Data/".
Residual misalignment: Default is our current estimate of
misalignment after all our alignment procedure has been applied.
Full misalignment: Default is our current estimate of initial
misalignment.

==========================================================
How to simulate events with misaligned geometry in local CDB
==========================================================

If you want to use a misaligned geometry to simulate some
events you can use a local CDB. For this need to follow
the next steps:

- Generate misaligned data in local CDB.
You can use MUONGenerateGeometryData.C as described above in
the corresponding section. Let's assume you used the default
residual misalignment settings, then you have a local CDB in
your working directory called ResMisAlignCDB containing
misalignement data (ResMisAlignCDB/MUON/Align).

- Copy the calibration data in your local CDB.
cp -r $ALICE_ROOT/MUON/Calib ResMisAlignCDB/MUON

- Tell AliSimulation you want to use your local CDB for MUON
To do this you need to instantiate the AliCDBManager, set the
default storage and set the specific storage for MUON, before
instantiating AliSimulation (see for example the commented
lines AlirootRun_MUONtest.sh).

aliroot -b  >& testSim.out << EOF
AliCDBManager* man = AliCDBManager::Instance();
man->SetDefaultStorage("local://$ALICE_ROOT");
man->SetSpecificStorage("MUON","local://ResMisAlignCDB");
AliSimulation MuonSim("$ALICE_ROOT/MUON/Config.C");
MuonSim.SetWriteRawData("MUON");
MuonSim.Run(10);
.q
EOF

==========================================================
 How to Merge events
==========================================================

You can merge 2 types of simulated events. For example, 
you can simulate Hijing events, and then simulate muons
merging both.

Merging is done at the sdigits level, so Kinematics files 
of the merged events will just correspond to the 
Config.C simulated file (not to Config_HIJING.C).

You must, first, do the Hijing simulation and store it 
in directory $HIJING_SIM. Note that for merging you 
won't need Kinematics files of the Hijing simulation...

Hijing simulation

aliroot -b << EOF
AliSimulation HijingSim("$HIJING_SIM/Config_HIJING.C")
HijingSim.Run(5)
.q
EOF


Then you can do muon simulation and reconstruction
merging both simulated events. In next example, we are
merging 20 times each Hijing event in order to simulate 
100 muons merged with 5 Hijing events.


aliroot -b << EOF
AliSimulation MuonSim("$ALICE_ROOT/MUON/Config.C")
MuonSim.MergeWith("$HIJING_SIM/galice.root",20) //parameters are the Hijing simulation file and the number of times we use each Hijing event
MuonSim.Run(100) // number of muon (Config.C) events
.q
EOF


aliroot -b << EOF
TPluginManager * pluginmanager = gROOT->GetPluginManager()
pluginmanager->AddHandler("AliReconstructor","MUON","AliMUONReconstructor","MUON","AliMUONReconstructor()")
AliReconstruction  MuonRec("galice.root")
MuonRec.SetRunTracking("")
MuonRec.SetRunVertexFinder(kFALSE)
MuonRec.SetRunLocalReconstruction("MUON")
MuonRec.SetFillESD("MUON")
MuonRec.Run()
.q
EOF

==========================================================
 How to play with the CDB
==========================================================

If you'd like to see how the CDB is created, please have a look at the 
MUONCDB.C (work in progress, though).

==========================================================
...on track numbering 
==========================================================

All generated particles, including primary and secondary
particles are put on the stack. The secondary particles are kept
in the stack only if they gave a hit in *any* of the ALICE detectors
The number of all particles placed on the stack for a given event 
can be obtained with
Int_t nPart = AliStack::GetNtrack();
Looping from 0 to nPart via AliStack::Particle(ipart)
gives the particle listing as obtained from the particle generator (primaries) 
and Monte Carlo (secondaries).

The particle response in the detector, a hit, is registered
in the hits tree and the hits are filled with each primary track.
The total number of "tracks" (fills of the tree) can be obtained
with ntracks = AliMUONData::GetNtracks() and is usually smaller than "nPart".
Since particles can also deposit hits in other detectors than 
the MUON spectrometer, there will be many "tracks" (fills) in the hit-tree
without a hit in MUON.

The correspondence between "track ID" in the hits-tree ("itr") and the
particle ID for particles on the stack (i.e. generated particles) can be
obtained via:
for (Int_t itr = 0; itr < ntracks; itr++) {
    MUONData->GetTrack(itr); //track "itr" of the hits-tree
    Int_t nhitstot = MUONData->Hits()->GetEntriesFast();
    AliMUONHit* mHit;    
    for (Int_t ihit=0; ihit<nhitstot; ihit++) {
       mHit = static_cast<AliMUONHit*>(MUONData->Hits()->At(ihit));
       Int_t id = muonHit->Track(); //gives particle ID on stack
       TParticle* particle = gAlice->Stack()->Particle(id);
    }  
}

During the procedure to go from hits to digits, the hits 
are summed up such that more than one track can contribute
to a given digit. As a consequence the method
Int_t AliMUONDigit::Track(Int_t trackID)
takes an argument, where "trackID" runs from 0 to 
AliMUONDigit::Ntracks() to provide the reference to *all*
tracks that contributed to it. The returned track ID is the one 
referred to in the hit-tree. To know which is the generated particle
that deposited a given digit one has to follow the sequence of the kind:


mDigit = static_cast<AliMUONDigit*>(digits->At(idigit));
for (int tr = 0; tr < mDigit->Ntracks(); tr++){
   Int_t hitTrackID = mDigit->Track(tr);
   MUONData->GetTrack(hitTrackID);
   mHit = static_cast<AliMUONHit*>(MUONData->Hits()->At(0));
                                  //just take first hit of given track
   Int_t numPart = mHit->Track(); //gives ID of particle on the stack
   Int_t idTrack  = mHit->Particle(); //gives flavour code of the particle
}
In this example, for simplicity, only the first hit of a 
hit-track is used to check the particle ID.

===========================================================
 Still working ..............
===========================================================
